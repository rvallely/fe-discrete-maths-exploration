import ReactFlow, {
    MiniMap,
    Controls,
    Background,
} from 'reactflow';
import 'reactflow/dist/style.css';
  
const centraliseNodesInLineage = (feNodes, startNode) => {
                // start node
            // find their parent in the next layer
            // find sibling in the current layer
            // calculate the centralisedXIndex of their parent
            // reset the parent position.x to the centralised position

    console.log('** centralising nodes in lineage **')
    let firstChild = startNode;
    for (let i = feNodes.length - 1; i > 0; i -= 1) {
        // find their parent in the next layer
        const nextParentIndex = feNodes[i - 1].findIndex(({ id }) => id === firstChild.data.parentNode);
        // find sibling in the current layer
        console.log('firstChild: ', JSON.stringify(firstChild));
        const children = feNodes[i].filter(({data: { parentNode, label }}) => { 
            // console.log('data.paretnNode: ', parentNode)
            // console.log('matching to parent: ', firstChild.data.parentNode);
            console.log('label: ', label, 'parentNode: ', parentNode)
            return parentNode === firstChild.data.parentNode
        });
        // calculate the centralisedXIndex of their parent
        console.log(JSON.stringify(
            feNodes[i].map(({data: {label, parentNode}}) => ({label, parentNode}))
            )
        );
        console.log('The children that share a parent are: ', children.map(({data: {label}}) => label));

        let centralisedParentXPosition;
        if (children.length === 1) {
            // **** check this is right possibly should match below where *** is)
            centralisedParentXPosition = children[0].position.x + 200;
            // feNodes[feNodes.length - 1][parentIndex].position.x = position.x + 100;
        } else {
            const [biggerX, smallerX] = children[0].position.x > children[1].position.x ? [children[0].position.x, children[1].position.x]: [children[1].position.x, children[0].position.x];
            centralisedParentXPosition = (biggerX - smallerX) / 2 + smallerX;
        }
        
        // reset the parent position.x to the centralised position
        console.log('centralising node: ', feNodes[i - 1][nextParentIndex].data.label)
        feNodes[i - 1][nextParentIndex].position.x = centralisedParentXPosition;
        // make the parent just centralised the new firstChild
        firstChild = feNodes[i - 1][nextParentIndex];
        // console.log('firstChild is now: ', feNodes[i - 1][nextParentIndex])
    }
}
const getPositionEdgeAndParent = (element, previousFeNodeLayer, currentFeNodeLayer, feNodes) => {
    /**
     * TODO: add a check to see if a previous node is at this position if so move it along another 100 or whatever
     * Will also need to make y 
     */
    if (!previousFeNodeLayer) {
      return {
        position: { x: 200, y: 0},
        edge: undefined,
      };
    } else {
      const parentFeNode = previousFeNodeLayer.find(({ id }) => id === element.previousNode.name);
      const edge = { id: `e-${parentFeNode.id}-${element.name}`, source: parentFeNode.id, target: element.name, type: 'straight', }
      const position = {};
  
      if (element.previousNode.position === 'left') {
        // add the default position for a left node element
        position.x = parentFeNode.position.x - 100;
        // if there's a node already in that position

        // currentFeNodeLayer.find(({ position: nodePositionInCurrentLayer }) => nodePositionInCurrentLayer.x === position.x)
        // find the biggest value on the current row
        /**
        console.log(currentFeNodeLayer, '<<< current fe node layer')
        console.log(currentFeNodeLayer.sort((a, b) => {
            console.log(a, b);
            return a - b;
        }))
        if (currentFeNodeLayer.length) {
            const [{ position: { x: rightMostXPosition }, data: { label }}] = currentFeNodeLayer.sort((a, b) => {
                console.log(a, b);
                return a.position.x - b.position.x
            });
            // console.log(biggestValueOnCurrentLayer, '<<< biggestValueOnCurrentLayer');
            if (rightMostXPosition) {
                if (position.x - 190 < rightMostXPosition) {
                    console.log(element.pivot, ' at ', parentFeNode.position.x - 100, ' overlapped ', label, ' at ', rightMostXPosition , ' moving 190px to the right');
                    // make sure new value does not overlap this
                    // nodePositionInCurrentLayer.x 
                    // position.x - 190 < nodePositionInCurrentLayer.x 
                    position.x = rightMostXPosition + 190;
                }
            }
        }
         */
        // else if no overlap
        // else {
        // if the biggest x value on the current row + 190 > position.x
        // then position.x = biggestValue on current row + 190
        // centralise the lineage
        if (currentFeNodeLayer.find(({ position: nodePositionInCurrentLayer }) => nodePositionInCurrentLayer.x === position.x)) {
            position.x = parentFeNode.position.x + 200;
            console.log('postion overlapped, changing now ... ');
            // **** check this is right (it was 200 but was causing overlap with [4, 3, 7, 9, 1, 0, 4, 34, 2, 78, 8] )
            // position.x = parentFeNode.position.x + 200;

            // offest the direct parent by 100
            const parentIndex = feNodes[feNodes.length - 1].findIndex(({ id }) => id === parentFeNode.id);
            console.log('centralising: ', feNodes[feNodes.length - 1][parentIndex].data.label)
            feNodes[feNodes.length - 1][parentIndex].position.x = position.x + 100;
            // go up tree and centralise the rest of the lineage, starting with parent just offeset for as the child
            // then starting with parent of that parent and its other sibling's parent
            // and so on until there are no more node layers to go through

            // for each centraliing operation need

            // start node
            // find their parent in the next layer
            // find sibling in the current layer
            // calculate the centralisedXIndex of their parent
            // reset the parent position.x to the centralised position
            centraliseNodesInLineage(feNodes, feNodes[feNodes.length - 1][parentIndex]);
        }
        
        // }
           

            
      } else {
        // do the same check for any overlap
        // offset node
        // centralise the lineage
          // with check for overlap again and resizing
        position.x = parentFeNode.position.x + 100;

        // if position overlaps with an element on the current row
          // move the element and centralise its lineage
          // if they cause over lap move the element and its lineage
          // etc
      }
      position.y = parentFeNode.position.y + 100;

      return {
        position,
        edge,
        parentNode: parentFeNode.id,
      }
    }
  }
  
  const getNodesAndEdges = (iterations) => {
    const nodes = [];
    const edges = [];
    for (let layer in iterations) {
        const currentFeNodeLayer = [];
        
        for (let element of iterations[layer]) {
            console.log('element: ', element.pivot);
            const {
                position,
                edge,
                parentNode,
            } = getPositionEdgeAndParent(element, nodes[nodes.length - 1], currentFeNodeLayer, nodes);
            if (edge) {
                edges.push(edge);
            };
            currentFeNodeLayer.push({
                id: element.name,
                data: {
                label: element.pivot,
                parentNode,
                },
                position,
                style: { backgroundColor: 'pink', border: 'dashed', borderColor: 'green'},
                width: 140,
            });
        }

        nodes.push(currentFeNodeLayer);
    }
    return {
      nodes: nodes.flat(),
      edges,
    }
  }
  function QuickSortProcess({iterations}){
    const { nodes, edges } = getNodesAndEdges(iterations);

    console.log(JSON.stringify(nodes.map(({ data: { label }, position}) => {
        return {
            label,
            position,
        }
    })));
  
    return (
    <div style={{ 'height': 1000, margin: 30, border: 'dashed', borderColor: 'yellow', position: 'relative', draggable: 'true' }}>
        <ReactFlow
        style={{border: 'solid', borderColor: 'green'}}
        nodes={nodes}
        edges={edges}
        selectionOnDrag={false}
        panOnDrag={true}
        nodesDraggable={true}
        nodesConnectable={false}
        snapToGrid={true}
        preventScrolling={true}
        panOnScroll={false}
        zoomOnScroll={false}
        fitView={true}
      >
        <MiniMap />
        <Controls />
        <Background/>
      </ReactFlow>
      </div>
    );
  }
  
  export default QuickSortProcess;
  